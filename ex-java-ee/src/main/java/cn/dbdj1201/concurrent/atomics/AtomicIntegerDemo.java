package cn.dbdj1201.concurrent.atomics;

/**
 * @author tyz1201
 * @datetime 2020-05-07 22:16
 **/
public class AtomicIntegerDemo {
    /*
    原子类，原理CAS，compare and swap

CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。CAS机制当中使用了3个基本操作数：
（1）内存地址V，也就是AtomicInteger中的valueOffset。
（2）旧的预期值A，也就是getAndIncrement方法中的current。
（3）要修改的新值B，也就是getAndIncrement方法中的next。

CAS机制中，更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。下面我们来看一个具体的例子：
（1）在内存地址V当中，存储着值为10的变量。
（2）此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。
（3）但是，在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。
（4）此时，线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。
（5）线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。
（6）这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。
（7）线程1进行替换，把地址V的值替换为B，也就是12。
      对比Synchronized，我们可以发现，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么
严重，所以让线程不断去尝试更新。

    但是CAS机制通常也存在以下缺点：
（1）ABA问题
       如果V的初始值是A，在准备赋值的时候检查到它仍然是A，那么能说它没有改变过吗？也许V经历了这样一个过程：它先变成了B，又变成了A，使用CAS检查时
以为它没变，其实却已经改变过了。
（2）CPU开销较大
     在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。
（3）不能保证代码块的原子性
     CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。
     */
}
