package cn.dbdj1201.ds.graph;

/**
 * @author tyz1201
 * @datetime 2020-05-13 8:59
 **/
public class Base {
    /*
    前边学了线性表和树
    这些都局限于一个直接前驱节点和一个或者多个直接后继节点
    图就可以表示多对多的关系。
    图也是一种数据结构，其中节点可以具有零个或者多个相邻元素。两个节点之间的连接称为边，节点也可以称为顶点。
    顶点(vertex)就是节点
    边（edge）
    路径：比如从D->C的路径有
             D->B->C
             D->A->B->C
    无向图 ：顶点之间的连接没有方向，比如A-B，既可以是A->B,也可以B->A
    有向图：顶点之间的连接有方向，比如A->B,只能是这个方向
    带权图：边带权值的图也叫网。
    图的表示方式：
        二维数组表示(邻接矩阵)
            是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是row和col表示的1....n个点。
        链表表示(邻接表)
            1，邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在，会造成空间的一定损失。
            2，邻接表的实现只关心存在的边，不关心不存在的边，因此没有空间浪费，邻接表由数组+链表组成。
            邻接表是用计算机语言来表示具体的图这种概念，其实一幅图要表示清楚，根据概念，只需要表示清楚图中的点以及连接这些点的边即可。
            那么在邻接表中，数组的索引代表图的顶点，此时点就表示清楚了，然后邻接表每个索引处的队列中的数据表示当前索引代表的顶点和哪些顶点可以组成一条
            边，因为两点成线。此时边也表示清楚了。这样就能把图表示出来了

     图的深度优化遍历介绍：
        图遍历介绍
            所谓图的遍历，即是对节点的访问，一个图有那么多个节点，如何遍历呢？
                1，深度优先遍历
                2，广度优先遍历
      图的深度优先搜索Depth First Search
      1,深度优先遍历，从初始访问节点出发，初始访问节点可能有多个邻接节点，深度优先遍历的策略就是首先访问第一个邻接节点，然后再以这个被访问的邻接节点作为
     初始节点，访问他的第一个邻接节点，可以这样理解：每次都在访问完当前节点后首先访问当前节点的第一个邻接节点。
      2，我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个节点的所有邻接节点进行横向访问
      3，显然，深入优先搜索是一个递归的过程。
      深度优先遍历算法步骤：
        1，访问初始节点V，并标记节点v为已访问。
        2，查找节点V的第一个邻接节点w
        3，若w存在，则继续执行4，不存在则回到第一步，将从v的下一个邻接节点继续
        4，若w未被访问，对w进行深度优先遍历递归（即把w当作另一个v，然后进行步骤123
        5，已经被访问过，查找节点v的w邻接节点的下一个邻接节点，转到3
      图的广度优先遍历算法：
        BFS broad first search
        类似分层搜索过程，广度优先遍历需要使用一个队列以保持访问过的节点的顺序，以便按这个顺序来访问这些节点的邻接节点。
        步骤：
            1，访问初始节点V并标记为已访问
            2，节点V入队
            3，当队列非空，继续执行，否则对于该节点来说算法结束
            4，出队，取得队头节点u
            5，查找节点u的第一个邻接节点w
            6，若节点u的邻接节点w不存在，则-》3，否则循环执行以下三个步骤
                ①，若节点w还未被访问，则访问节点w并标记为已访问
                ②，节点w入队
                ③，查找节点u的继w邻接节点后的下一个邻接节点w，=》6

        图的深度优先VS广度优先

     */

}
