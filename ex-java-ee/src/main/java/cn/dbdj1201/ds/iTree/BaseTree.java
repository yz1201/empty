package cn.dbdj1201.ds.iTree;

/**
 * @author tyz1201
 * @datetime 2020-05-06 10:36
 **/
public class BaseTree {
    /*
    数组存储方式分析：
        查找/检索快
            直接定位，二分法，插值，斐波那契。
        增删慢
            增删会涉及到数组扩容以及迁移
    链式存储方式分析：
        查找/检索慢
            对于，单链表，每次都得从头遍历
        增删较快
            对于某个节点而言只需对该节点进行增删，实际上也需先找到该节点，不过效率也比数组存储高。
    树存储方式分析：
        相对来说，查找，增删都比较快，对于二叉排序树来说，因为是按一定顺序存储的，找起来很快，而且增删时涉及到的内容也不多。

     树的常用术语：
        节点：每一个数据源
        根节点：最老的父节点
        父节点：
        子节点：
        叶子节点：无字节的的节点
        节点的权：节点值
        路径：从根节点到该节点的路线
        层：同一辈的
        子树：一大家拉出来一部分
        树的高度：最大层数
        森林：多颗子树构成森林
      二叉树：
        每个节点最多有两个子节点的树。
        它的子节点只有左节点跟右节点
        如果该二叉树的所有叶子节点都在最后一层，并且节点总数=2^n-1，n为层数，称为满二叉树，因为确实满了
        如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。
      二叉树的遍历：
         前序：先输出父节点，再遍历左子树和右子树
            先输出root节点
            如果左子节点不为空，递归进行前序遍历
            如果右子节点不为空，递归前序遍历
         中序：先遍历左子树，再输出父节点，再遍历右子树
         后序：先遍历左子树，再遍历右子树，最后输出子节点
         所有我们只需要看父节点输出顺序，就可以判断是哪种遍历。
     */
}
